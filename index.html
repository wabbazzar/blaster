<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Card Blaster - Arcade Flashcard Learning Game</title>
    <meta name="description" content="Card Blaster: An arcade-style flashcard learning game with Tron aesthetic. Learn data science concepts while playing!">
    <meta name="keywords" content="flashcards, learning game, data science, arcade game, education">
    <meta name="author" content="Card Blaster Team">
    
    <!-- Open Graph meta tags for social sharing -->
    <meta property="og:title" content="Card Blaster - Arcade Flashcard Learning Game">
    <meta property="og:description" content="Learn data science concepts through an exciting arcade-style game!">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://wabbazzar.github.io/blaster/">
    
    <!-- Twitter Card meta tags -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Card Blaster">
    <meta name="twitter:description" content="Arcade-style flashcard learning game">
    
    <style>
        /* Mobile-first Tron aesthetic */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            background: #000000;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100vh;
            height: 100dvh;
            touch-action: manipulation;
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        #wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            height: 100vh;
            height: 100dvh;
            padding: 10px;
            box-sizing: border-box;
            overflow: hidden;
            width: 100%;
            position: relative;
        }
        
        h1 {
            font-size: clamp(1.5rem, 5vw, 2.5rem);
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
            animation: neonFlicker 2s ease-in-out infinite alternate;
            margin-bottom: 10px;
        }
        
        @keyframes neonFlicker {
            0%, 100% {
                text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
            }
            50% {
                text-shadow: 0 0 25px #00ffff, 0 0 50px #00ffff, 0 0 70px #00ffff;
            }
        }
        
        #questionArea {
            width: min(400px, 90vw);
            height: 100px;
            border: 2px solid #00ffff;
            border-radius: 8px;
            box-shadow: 0 0 15px #00ffff;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 255, 255, 0.05);
            padding: 10px;
        }
        
        #questionText {
            font-size: clamp(12px, 3vw, 14px);
            text-align: center;
            color: #ffffff;
        }
        
        #scoreArea {
            width: min(400px, 90vw);
            height: 50px;
            border: 2px solid #00ffff;
            border-radius: 8px;
            box-shadow: 0 0 10px #00ffff;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            background: rgba(0, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        #scoreArea:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px #00ffff;
        }
        
        .score-section {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .score-item {
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            font-size: clamp(14px, 3vw, 16px);
            font-weight: bold;
        }
        
        .level-item {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            font-size: clamp(14px, 3vw, 16px);
            font-weight: bold;
        }
        
        .lives-item {
            color: #ff0099;
            text-shadow: 0 0 10px #ff0099;
            font-size: clamp(14px, 3vw, 16px);
            font-weight: bold;
        }
        
        .deck-selector {
            margin: 20px 0;
            text-align: center;
        }
        
        .deck-label {
            display: block;
            color: #00ffff;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        .deck-dropdown {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 8px;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            padding: 10px 15px;
            min-width: 250px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .deck-dropdown:hover {
            border-color: #ff6600;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }
        
        .deck-dropdown:focus {
            outline: none;
            border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }
        
        .deck-dropdown option {
            background: #000000;
            color: #00ffff;
            padding: 8px;
        }
        
        .card-state-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            z-index: 10;
        }
        
        .card-state-new {
            background: #ffff00;
            box-shadow: 0 0 5px #ffff00;
        }
        
        .card-state-struggling {
            background: #ff6600;
            box-shadow: 0 0 5px #ff6600;
        }
        
        .card-state-learned {
            background: #00ff00;
            box-shadow: 0 0 5px #00ff00;
        }
        
        /* Toggle switch for correct answer highlighting */
        .highlight-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: clamp(10px, 2.5vw, 12px);
            color: #ffff00;
            text-shadow: 0 0 5px #ffff00;
        }
        
        .toggle-switch {
            position: relative;
            width: 40px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid #00ffff;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .toggle-switch.active {
            background: rgba(0, 255, 0, 0.3);
            box-shadow: 0 0 10px #00ff00;
        }
        
        .toggle-slider {
            position: absolute;
            top: 1px;
            left: 1px;
            width: 16px;
            height: 16px;
            background: #00ffff;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 0 5px #00ffff;
        }
        
        .toggle-switch.active .toggle-slider {
            transform: translateX(18px);
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }
        
        #gameBoard {
            position: relative;
            width: min(400px, 90vw);
            height: min(600px, 60vh);
            border: 2px solid #00ffff;
            border-radius: 8px;
            box-shadow: 0 0 15px #00ffff;
            background: rgba(0, 0, 0, 0.8);
            overflow: hidden;
            flex: 1;
            max-height: 600px;
        }
        
        #ship {
            position: absolute;
            bottom: 20px;
            left: 180px;
            width: 40px;
            height: 40px;
            background: #00ffff;
            border-radius: 5px;
            box-shadow: 0 0 10px #00ffff;
        }
        
        /* Game state overlays */
        .game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.95);
            z-index: 100;
            padding: 20px;
            display: none;
        }
        
        .game-overlay.active {
            display: flex;
        }
        
        .overlay-title {
            font-size: clamp(2rem, 8vw, 3.5rem);
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.2rem;
            font-weight: bold;
        }
        
        .menu-title {
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff, 0 0 60px #00ffff;
            animation: neonFlicker 2s ease-in-out infinite alternate;
        }
        
        .pause-title {
            color: #ffff00;
            text-shadow: 0 0 20px #ffff00, 0 0 40px #ffff00, 0 0 60px #ffff00;
        }
        
        .overlay-subtitle {
            font-size: clamp(1rem, 4vw, 1.5rem);
            color: #ff6600;
            text-shadow: 0 0 10px #ff6600, 0 0 20px #ff6600;
            margin-bottom: 2rem;
            text-transform: uppercase;
            letter-spacing: 0.1rem;
        }
        
        .overlay-text {
            font-size: clamp(1rem, 3vw, 1.2rem);
            opacity: 0.8;
            margin-bottom: 2rem;
            text-transform: uppercase;
            letter-spacing: 0.1rem;
            text-align: center;
        }
        
        .controls-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            margin-bottom: 2rem;
            width: 100%;
            max-width: 400px;
        }
        
        .control-section {
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            padding: 1rem;
        }
        
        .control-title {
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            font-size: clamp(0.9rem, 3vw, 1.1rem);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
        }
        
        .control-item {
            color: #ffffff;
            font-size: clamp(0.8rem, 2.5vw, 1rem);
            opacity: 0.8;
            margin: 0.3rem 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .control-key {
            color: #ffff00;
            text-shadow: 0 0 5px #ffff00;
            font-weight: bold;
        }
        
        .start-button {
            background: linear-gradient(45deg, #00ffff, #0099ff);
            border: none;
            padding: 1rem 3rem;
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            text-transform: uppercase;
            letter-spacing: 0.1rem;
            cursor: pointer;
            box-shadow: 0 0 20px #00ffff;
            transition: all 0.3s ease;
            color: #000;
            font-weight: bold;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }
        
        .start-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transform: translate(-50%, -50%) rotate(45deg) scale(0);
            transition: transform 0.6s;
        }
        
        .start-button:hover::before {
            transform: translate(-50%, -50%) rotate(45deg) scale(2);
        }
        
        .start-button:active {
            transform: scale(0.95);
        }
        
        /* Practice Mode Section in Start Overlay */
        .practice-mode-section {
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            width: 100%;
            max-width: 400px;
        }
        
        .practice-title {
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            font-size: clamp(1rem, 3vw, 1.2rem);
            margin-bottom: 10px;
            text-transform: uppercase;
            text-align: center;
        }
        
        .practice-mode-section .highlight-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-size: clamp(0.9rem, 2.5vw, 1rem);
            color: #ffff00;
            text-shadow: 0 0 5px #ffff00;
        }
        
        /* Target styles */
        .target {
            transition: all 0.1s ease;
        }
        
        .target.correct-highlighted {
            background: #00ff00 !important;
            border-color: #00ff00 !important;
            box-shadow: 0 0 15px #00ff00;
        }
        
        .target.correct-normal {
            background: #ff6600 !important;
            border: 2px solid #00ffff !important;
        }
        
        /* Responsive design */
        @media (max-width: 480px) {
            #wrapper {
                padding: 5px;
                gap: 5px;
            }
            
            .highlight-toggle {
                font-size: 10px;
            }
            
            .toggle-switch {
                width: 30px;
                height: 16px;
            }
            
            .toggle-slider {
                width: 12px;
                height: 12px;
            }
            
            .toggle-switch.active .toggle-slider {
                transform: translateX(12px);
            }
        }
        
        /* Pause indicator */
        .pause-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #ffff00;
            font-size: 12px;
            text-shadow: 0 0 5px #ffff00;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .pause-indicator.visible {
            opacity: 1;
        }
        
        /* Mobile-first responsive visibility classes */
        .mobile-only {
            display: block;
        }
        
        .desktop-only {
            display: none;
        }
        
        @media (min-width: 768px) {
            .mobile-only {
                display: none;
            }
            
            .desktop-only {
                display: block;
            }
        }
        
        /* Make pause overlay clickable for resume */
        #pauseOverlay {
            cursor: pointer;
        }
        
        #pauseOverlay:hover {
            background: rgba(0, 0, 0, 0.98);
        }
        
        /* Level completion animations */
        @keyframes levelCompleteFlash {
            0% {
                opacity: 0;
            }
            20% {
                opacity: 1;
            }
            80% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }
        
        @keyframes levelCompleteText {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            20% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            40% {
                transform: translate(-50%, -50%) scale(1);
            }
            80% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
        }
        
        @keyframes levelAdvanceText {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) translateY(30px);
            }
            35% {
                opacity: 1;
                transform: translate(-50%, -50%) translateY(0px);
            }
            80% {
                opacity: 1;
                transform: translate(-50%, -50%) translateY(0px);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) translateY(-15px);
            }
        }
        
        /* Victory animations */
        @keyframes victoryRainbow {
            0% {
                opacity: 0;
                transform: rotate(0deg);
            }
            20% {
                opacity: 0.8;
            }
            100% {
                opacity: 0.6;
                transform: rotate(360deg);
            }
        }
        
        @keyframes victoryText {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.3) rotateY(180deg);
            }
            20% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.3) rotateY(0deg);
            }
            40% {
                transform: translate(-50%, -50%) scale(1.1) rotateY(-10deg);
            }
            60% {
                transform: translate(-50%, -50%) scale(1.2) rotateY(10deg);
            }
            80% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1) rotateY(0deg);
            }
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1) rotateY(0deg);
            }
        }
        
        @keyframes masteryText {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            30% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            80% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        
        @keyframes finalScoreText {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) translateY(50px);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) translateY(0px);
            }
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) translateY(0px);
            }
        }
    </style>
</head>
<body>
    <div id="wrapper">
        <h1>Card Blaster</h1>

        <!-- Question Area -->
        <div id="questionArea">
            <div id="questionText">Question goes here</div>
        </div>

        <!-- Score Display WITH Lives -->
        <div id="scoreArea">
            <div class="score-section">
                <div class="score-item">Score: <span id="scoreValue">0</span></div>
                <div class="level-item">Level: <span id="levelValue">1</span></div>
                <div class="lives-item">Lives: <span id="livesValue">5</span></div>
            </div>
            
            <div class="pause-indicator" id="pauseIndicator">PAUSED</div>
        </div>

        <!-- Game Board -->
        <div id="gameBoard">
            <!-- Ship -->
            <div id="ship"></div>
        </div>
    </div>

    <!-- Start Menu Overlay -->
    <div class="game-overlay active" id="startOverlay">
        <h1 class="overlay-title menu-title">Card Blaster</h1>
        <p class="overlay-subtitle">Arcade Learning Game</p>
        
        <!-- Deck Selection (ONLY in start screen) -->
        <div class="deck-selector">
            <label for="deckSelect" class="deck-label">Select Learning Deck:</label>
            <select id="deckSelect" class="deck-dropdown">
                <option value="data_science_cards.json">Data Science Fundamentals</option>
                <option value="chinese_language_cards.json">Chinese Language Basics</option>
            </select>
        </div>
        
        <!-- Practice Mode Toggle Section (ONLY in start screen) -->
        <div class="practice-mode-section">
            <div class="practice-title">Practice Mode</div>
            <div class="highlight-toggle">
                <span>Highlight Correct Answers</span>
                <div class="toggle-switch active" id="highlightToggle">
                    <div class="toggle-slider"></div>
                </div>
            </div>
        </div>
        
        <div class="controls-container">
            <div class="control-section">
                <div class="control-title">Desktop Controls</div>
                <div class="control-item">
                    <span class="control-key">‚Üê ‚Üí</span> Move ship left/right
                </div>
                <div class="control-item">
                    <span class="control-key">SPACE</span> Fire projectile
                </div>
                <div class="control-item">
                    <span class="control-key">Click Scoreboard</span> Pause/Resume
                </div>
            </div>
            
            <div class="control-section">
                <div class="control-title">Mobile Controls</div>
                <div class="control-item">
                    <span class="control-key">Tap Left Zone</span> Move ship left
                </div>
                <div class="control-item">
                    <span class="control-key">Tap Right Zone</span> Move ship right
                </div>
                <div class="control-item">
                    <span class="control-key">Swipe Left/Right</span> Move ship left/right
                </div>
                <div class="control-item">
                    <span class="control-key">Tap Game Board</span> Fire projectile
                </div>
                <div class="control-item">
                    <span class="control-key">Swipe Down</span> Continuous fire
                </div>
                <div class="control-item">
                    <span class="control-key">Long Press</span> Rapid fire
                </div>
                <div class="control-item">
                    <span class="control-key">Tap Scoreboard</span> Pause/Resume
                </div>
            </div>
        </div>
        
        <p class="overlay-text">Shoot the correct answers to learn!</p>
        <button class="start-button" id="startButton">Start Game</button>
    </div>
    
    <!-- Pause Overlay -->
    <div class="game-overlay" id="pauseOverlay">
        <h1 class="overlay-title pause-title">Paused</h1>
        <p class="overlay-text mobile-only">Tap anywhere to resume</p>
        <p class="overlay-text desktop-only">Press P or click here to resume</p>
    </div>

    <script>
        // Game State Management
        let gameRunning = false;
        let gamePaused = false;
        let highlightCorrectAnswers = true; // Default to ON
        
        // Game loop intervals
        let projectileInterval = null;
        let targetInterval = null;
        
        // Initialize game state
        function initializeGame() {
            gameRunning = false;
            gamePaused = false;
            
            // Setup toggle switch
            setupHighlightToggle();
            
            // Setup scoreboard click for pause/resume
            setupScoreboardControls();
            
            // Setup pause overlay for resume
            setupPauseOverlay();
            
            // Setup touch controls for mobile
            setupTouchControls();
            
            // Setup start button
            setupStartButton();
            
            // Setup deck selection
            setupDeckSelection();
            
            console.log('Game initialized');
        }
        
        // Setup highlight toggle functionality (now on start screen)
        function setupHighlightToggle() {
            const toggle = document.getElementById('highlightToggle');
            toggle.addEventListener('click', function(e) {
                // No need to prevent bubbling since it's not in scoreboard anymore
                e.stopPropagation();
                
                highlightCorrectAnswers = !highlightCorrectAnswers;
                
                // Update toggle visual state
                if (highlightCorrectAnswers) {
                    toggle.classList.add('active');
                } else {
                    toggle.classList.remove('active');
                }
                
                // Update existing targets (if any)
                updateTargetHighlighting();
                
                console.log('Highlight toggle:', highlightCorrectAnswers ? 'ON' : 'OFF');
            });
            
            // Also prevent touch events from bubbling
            toggle.addEventListener('touchstart', function(e) {
                e.stopPropagation();
            });
        }
        
        // Update target highlighting based on toggle state
        function updateTargetHighlighting() {
            targets.forEach(target => {
                if (target.isCorrect) {
                    target.element.className = 'target';
                    if (highlightCorrectAnswers) {
                        target.element.classList.add('correct-highlighted');
                    } else {
                        target.element.classList.add('correct-normal');
                    }
                }
            });
        }
        
        // Setup scoreboard controls for pause/resume (simplified - no toggle)
        function setupScoreboardControls() {
            const scoreArea = document.getElementById('scoreArea');
            const pauseIndicator = document.getElementById('pauseIndicator');
            
            scoreArea.addEventListener('click', function() {
                if (!gameRunning) return; // Only allow pause/resume when game is running
                
                if (gamePaused) {
                    resumeGame();
                } else {
                    pauseGame();
                }
            });
            
            // Add touch support for mobile
            scoreArea.addEventListener('touchstart', function(e) {
                e.preventDefault();
                if (!gameRunning) return;
                
                if (gamePaused) {
                    resumeGame();
                } else {
                    pauseGame();
                }
            });
        }
        
        // Setup pause overlay for mobile-friendly resume
        function setupPauseOverlay() {
            const pauseOverlay = document.getElementById('pauseOverlay');
            
            // Make pause overlay clickable to resume
            pauseOverlay.addEventListener('click', function() {
                if (gamePaused && gameRunning) {
                    resumeGame();
                    console.log('Game resumed via pause overlay click');
                }
            });
            
            // Add touch support for mobile
            pauseOverlay.addEventListener('touchstart', function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (gamePaused && gameRunning) {
                    resumeGame();
                    console.log('Game resumed via pause overlay touch');
                }
            });
        }
        
        // Pause game
        function pauseGame() {
            if (!gameRunning || gamePaused) return;
            
            gamePaused = true;
            
            // Stop game loops
            if (projectileInterval) {
                clearInterval(projectileInterval);
                projectileInterval = null;
            }
            if (targetInterval) {
                clearInterval(targetInterval);
                targetInterval = null;
            }
            
            // Show pause overlay and indicator
            document.getElementById('pauseOverlay').classList.add('active');
            document.getElementById('pauseIndicator').classList.add('visible');
            
            console.log('Game paused');
        }
        
        // Resume game
        function resumeGame() {
            if (!gameRunning || !gamePaused) return;
            
            gamePaused = false;
            
            // Restart game loops
            startGameLoops();
            
            // Hide pause overlay and indicator
            document.getElementById('pauseOverlay').classList.remove('active');
            document.getElementById('pauseIndicator').classList.remove('visible');
            
            console.log('Game resumed');
        }
        
        // Setup start button
        function setupStartButton() {
            const startButton = document.getElementById('startButton');
            
            startButton.addEventListener('click', function() {
                startGame();
            });
            
            // Add touch support for mobile
            startButton.addEventListener('touchstart', function(e) {
                e.preventDefault();
                startGame();
            });
        }
        
        // Start game
        function startGame() {
            // Hide start overlay
            document.getElementById('startOverlay').classList.remove('active');
            
            // Reset game state
            gameRunning = true;
            gamePaused = false;
            score = 0;
            level = 1;
            lives = 5; // Reset lives
            currentProgressionLevel = 1; // Reset progression level
            
            // Update displays
            updateScore(0);
            updateLevel(1);
            updateLivesDisplay();
            
            // Clear existing targets and projectiles
            targets.forEach(target => target.element.remove());
            targets = [];
            projectiles.forEach(proj => proj.element.remove());
            projectiles = [];
            
            // Start game loops
            startGameLoops();
            
            // Initialize progressive gameplay
            initializeProgressiveGameplay();
            
            console.log('Game started with progressive gameplay');
        }
        
        // Initialize progressive gameplay system
        async function initializeProgressiveGameplay() {
            try {
                // Discover available decks
                await discoverAvailableDecks();
                
                // Get selected deck from dropdown
                const deckSelect = document.getElementById('deckSelect');
                const selectedDeckFilename = deckSelect.value;
                
                // Load the selected deck
                await loadSelectedDeck(selectedDeckFilename, 1);
            } catch (error) {
                console.error('Error initializing progressive gameplay:', error);
                // Fallback to default deck loading
                await loadDefaultDeck();
            }
        }
        
        // Start game update loops
        function startGameLoops() {
            if (projectileInterval) clearInterval(projectileInterval);
            if (targetInterval) clearInterval(targetInterval);
            
            projectileInterval = setInterval(() => {
                if (!gamePaused) updateProjectiles();
            }, 50);
            
            targetInterval = setInterval(() => {
                if (!gamePaused) updateTargets();
            }, 50);
        }
        
        // Phase 6: Data Integration - Enhanced with Progressive Gameplay
        let flashcards = [];
        let currentQuestion = null;
        let availableDecks = [];
        let selectedDeck = null;
        let currentProgressionLevel = 1;
        
        // Progressive Card Learning System
        let cardStates = new Map(); // Maps card ID to { state, consecutiveCorrect }
        let learnedCards = new Set();
        let strugglingCards = new Set();
        
        // Phase 7: Scoring System - Enhanced
        let score = 0;
        let level = 1;
        let lives = 5; // Starting lives
        let maxLives = 10;

        function updateScore(points) {
            const oldScore = score;
            score += points;
            document.getElementById('scoreValue').textContent = score;
            
            // Progressive Gameplay: Gain life every 1000 points
            if (points > 0) {
                const oldThousands = Math.floor(oldScore / 1000);
                const newThousands = Math.floor(score / 1000);
                
                if (newThousands > oldThousands) {
                    const livesGained = newThousands - oldThousands;
                    for (let i = 0; i < livesGained; i++) {
                        gainLife('score_milestone');
                    }
                }
            }
            
            console.log('Score updated:', score);
        }

        function updateLevel(newLevel) {
            level = newLevel;
            document.getElementById('levelValue').textContent = level;
            console.log('Level updated:', level);
        }

        // Progressive Gameplay: Deck Discovery System
        async function discoverAvailableDecks() {
            const potentialDecks = [
                'data_science_cards.json',
                'chinese_language_cards.json'
            ];
            
            availableDecks = [];
            
            for (const deckFile of potentialDecks) {
                try {
                    const response = await fetch(`assets/${deckFile}`);
                    if (response.ok) {
                        const deckData = await response.json();
                        if (deckData.metadata && deckData.cards) {
                            availableDecks.push({
                                filename: deckFile,
                                metadata: deckData.metadata,
                                cards: deckData.cards
                            });
                            console.log(`Discovered deck: ${deckData.metadata.deck_name}`);
                        }
                    }
                } catch (error) {
                    console.warn(`Could not load deck ${deckFile}:`, error);
                }
            }
            
            return availableDecks;
        }
        
        async function loadSelectedDeck(deckFilename, startingLevel = 1) {
            try {
                const deck = availableDecks.find(d => d.filename === deckFilename);
                if (!deck) {
                    throw new Error(`Deck ${deckFilename} not found`);
                }
                
                selectedDeck = deck;
                flashcards = deck.cards;
                currentProgressionLevel = startingLevel;
                
                // Initialize card states
                initializeCardStates();
                
                console.log(`Loaded deck: ${deck.metadata.deck_name}`);
                console.log(`Starting at level: ${startingLevel}`);
                console.log(`Total cards: ${flashcards.length}`);
                
                loadNewQuestion();
            } catch (error) {
                console.error('Error loading selected deck:', error);
                // Fallback to default data science deck
                await loadDefaultDeck();
            }
        }
        
        async function loadDefaultDeck() {
            try {
                const response = await fetch('assets/data_science_cards.json');
                const deckData = await response.json();
                selectedDeck = {
                    filename: 'data_science_cards.json',
                    metadata: deckData.metadata,
                    cards: deckData.cards
                };
                flashcards = deckData.cards;
                currentProgressionLevel = 1;
                initializeCardStates();
                loadNewQuestion();
            } catch (error) {
                console.error('Error loading default deck:', error);
                // Ultimate fallback
                flashcards = [{
                    "id": 1,
                    "term": "Machine Learning",
                    "definition": "A type of artificial intelligence where computers learn patterns from data",
                    "wrong_answers": ["Data Mining", "Statistical Analysis", "Computer Vision"],
                    "progression_level": 1
                }];
                initializeCardStates();
                loadNewQuestion();
            }
        }
        
        // Initialize card learning states
        function initializeCardStates() {
            cardStates.clear();
            learnedCards.clear();
            strugglingCards.clear();
            
            flashcards.forEach(card => {
                cardStates.set(card.id, {
                    state: 'new',
                    consecutiveCorrect: 0
                });
            });
        }

        // Progressive Learning: Handle correct answer
        function handleCorrectAnswer(card) {
            if (!card || !cardStates.has(card.id)) return;
            
            const cardState = cardStates.get(card.id);
            
            if (cardState.state === 'new') {
                // New card becomes learned immediately on correct answer
                cardState.state = 'learned';
                learnedCards.add(card.id);
                console.log(`Card "${card.term}" learned!`);
                
                // Check if level is complete
                checkLevelCompletion();
                
            } else if (cardState.state === 'struggling') {
                // Struggling card needs 2 consecutive correct answers
                cardState.consecutiveCorrect++;
                console.log(`Card "${card.term}" progress: ${cardState.consecutiveCorrect}/2`);
                
                if (cardState.consecutiveCorrect >= 2) {
                    cardState.state = 'learned';
                    learnedCards.add(card.id);
                    strugglingCards.delete(card.id);
                    console.log(`Card "${card.term}" mastered after struggle!`);
                    
                    // Check if level is complete
                    checkLevelCompletion();
                }
            }
            
            // Update card state
            cardStates.set(card.id, cardState);
        }
        
        // Progressive Learning: Handle wrong answer
        function handleWrongAnswer(card) {
            if (!card || !cardStates.has(card.id)) return;
            
            const cardState = cardStates.get(card.id);
            
            if (cardState.state === 'new') {
                // New card becomes struggling on wrong answer
                cardState.state = 'struggling';
                cardState.consecutiveCorrect = 0;
                strugglingCards.add(card.id);
                console.log(`Card "${card.term}" is now struggling`);
                
            } else if (cardState.state === 'struggling') {
                // Reset consecutive counter for struggling card
                cardState.consecutiveCorrect = 0;
                console.log(`Card "${card.term}" consecutive counter reset`);
            }
            
            // Update card state
            cardStates.set(card.id, cardState);
            
            // Lose a life for wrong answer
            loseLife('wrong_answer');
        }
        
        // Enhanced Lives System
        function loseLife(reason) {
            lives--;
            console.log(`Lost life (${reason}): ${lives} remaining`);
            
            // Update lives display
            updateLivesDisplay();
            
            if (lives <= 0) {
                gameOver();
            }
        }
        
        function gainLife(reason) {
            if (lives < maxLives) {
                lives++;
                console.log(`Gained life (${reason}): ${lives} total`);
                updateLivesDisplay();
            }
        }
        
        function updateLivesDisplay() {
            document.getElementById('livesValue').textContent = lives;
            console.log(`Lives: ${lives}/${maxLives}`);
        }
        
        // Check if current level is complete
        function checkLevelCompletion() {
            const currentLevelCards = flashcards.filter(card => 
                card.progression_level === currentProgressionLevel
            );
            
            const learnedInLevel = currentLevelCards.filter(card => 
                learnedCards.has(card.id)
            ).length;
            
            console.log(`Level ${currentProgressionLevel} progress: ${learnedInLevel}/${currentLevelCards.length}`);
            
            if (learnedInLevel === currentLevelCards.length) {
                levelComplete();
            }
        }
        
        // Handle level completion
        function levelComplete() {
            console.log(`üéâ LEVEL ${currentProgressionLevel} COMPLETE! üéâ`);
            
            // Show level completion animation
            showLevelCompletionAnimation();
            
            // Check if there are more levels
            const nextLevel = currentProgressionLevel + 1;
            const nextLevelCards = flashcards.filter(card => 
                card.progression_level === nextLevel
            );
            
            if (nextLevelCards.length > 0) {
                currentProgressionLevel = nextLevel;
                console.log(`Advancing to Level ${currentProgressionLevel}`);
                
                // Update level display
                updateLevel(currentProgressionLevel);
                
                // Initialize new level cards
                nextLevelCards.forEach(card => {
                    if (!cardStates.has(card.id)) {
                        cardStates.set(card.id, {
                            state: 'new',
                            consecutiveCorrect: 0
                        });
                    }
                });
                
            } else {
                // All levels complete - victory!
                victoryComplete();
            }
        }
        
        // Show level completion animation
        function showLevelCompletionAnimation() {
            // Create animation overlay
            const overlay = document.createElement('div');
            overlay.className = 'level-completion-overlay';
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.background = 'radial-gradient(circle, rgba(0,255,0,0.3) 0%, rgba(0,255,0,0.1) 40%, transparent 70%)';
            overlay.style.pointerEvents = 'none';
            overlay.style.zIndex = '999';
            overlay.style.opacity = '0';
            overlay.style.animation = 'levelCompleteFlash 2s ease-out forwards';
            
            // Add level complete text
            const levelText = document.createElement('div');
            levelText.className = 'level-complete-text';
            levelText.textContent = `LEVEL ${currentProgressionLevel} COMPLETE!`;
            levelText.style.position = 'absolute';
            levelText.style.top = '40%';
            levelText.style.left = '50%';
            levelText.style.transform = 'translate(-50%, -50%)';
            levelText.style.fontSize = 'clamp(2rem, 8vw, 3.5rem)';
            levelText.style.fontWeight = 'bold';
            levelText.style.color = '#00ff00';
            levelText.style.textShadow = '0 0 20px #00ff00, 0 0 40px #00ff00, 0 0 60px #00ff00';
            levelText.style.textAlign = 'center';
            levelText.style.fontFamily = 'Courier New, monospace';
            levelText.style.letterSpacing = '0.2em';
            levelText.style.opacity = '0';
            levelText.style.animation = 'levelCompleteText 2s ease-out forwards';
            
            // Add advancement text
            const advanceText = document.createElement('div');
            advanceText.className = 'level-advance-text';
            advanceText.textContent = `ADVANCING TO LEVEL ${currentProgressionLevel + 1}`;
            advanceText.style.position = 'absolute';
            advanceText.style.top = '60%';
            advanceText.style.left = '50%';
            advanceText.style.transform = 'translate(-50%, -50%)';
            advanceText.style.fontSize = 'clamp(1rem, 4vw, 1.5rem)';
            advanceText.style.fontWeight = 'bold';
            advanceText.style.color = '#00ffff';
            advanceText.style.textShadow = '0 0 10px #00ffff, 0 0 20px #00ffff';
            advanceText.style.textAlign = 'center';
            advanceText.style.fontFamily = 'Courier New, monospace';
            advanceText.style.letterSpacing = '0.1em';
            advanceText.style.opacity = '0';
            advanceText.style.animation = 'levelAdvanceText 2s ease-out forwards 0.5s';
            
            overlay.appendChild(levelText);
            overlay.appendChild(advanceText);
            document.body.appendChild(overlay);
            
            // Trigger haptic feedback if supported
            if ('vibrate' in navigator) {
                navigator.vibrate([200, 100, 200, 100, 200]);
            }
            
            // Remove overlay after animation
            setTimeout(() => {
                if (overlay.parentNode) {
                    overlay.parentNode.removeChild(overlay);
                }
            }, 2500);
            
            console.log(`Level completion animation: Level ${currentProgressionLevel}`);
        }
        
        // Handle game victory
        function victoryComplete() {
            console.log('üèÜ VICTORY! All cards mastered! üèÜ');
            
            // Show victory animation
            showVictoryAnimation();
            
            // Stop game
            gameRunning = false;
            gamePaused = false;
            
            // Stop game loops
            if (projectileInterval) clearInterval(projectileInterval);
            if (targetInterval) clearInterval(targetInterval);
        }
        
        // Show victory animation
        function showVictoryAnimation() {
            // Create victory overlay
            const overlay = document.createElement('div');
            overlay.className = 'victory-overlay';
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.background = 'conic-gradient(from 0deg, rgba(255,0,153,0.3), rgba(0,255,255,0.3), rgba(0,255,0,0.3), rgba(255,102,0,0.3), rgba(153,0,255,0.3), rgba(255,255,0,0.3), rgba(255,0,153,0.3))';
            overlay.style.pointerEvents = 'none';
            overlay.style.zIndex = '999';
            overlay.style.opacity = '0';
            overlay.style.animation = 'victoryRainbow 3s ease-out forwards';
            
            // Add victory text
            const victoryText = document.createElement('div');
            victoryText.className = 'victory-text';
            victoryText.textContent = 'VICTORY!';
            victoryText.style.position = 'absolute';
            victoryText.style.top = '30%';
            victoryText.style.left = '50%';
            victoryText.style.transform = 'translate(-50%, -50%)';
            victoryText.style.fontSize = 'clamp(3rem, 12vw, 5rem)';
            victoryText.style.fontWeight = 'bold';
            victoryText.style.color = '#ffff00';
            victoryText.style.textShadow = '0 0 30px #ffff00, 0 0 60px #ffff00, 0 0 90px #ffff00';
            victoryText.style.textAlign = 'center';
            victoryText.style.fontFamily = 'Courier New, monospace';
            victoryText.style.letterSpacing = '0.3em';
            victoryText.style.opacity = '0';
            victoryText.style.animation = 'victoryText 3s ease-out forwards';
            
            // Add mastery text
            const masteryText = document.createElement('div');
            masteryText.className = 'mastery-text';
            masteryText.textContent = 'ALL CARDS MASTERED!';
            masteryText.style.position = 'absolute';
            masteryText.style.top = '50%';
            masteryText.style.left = '50%';
            masteryText.style.transform = 'translate(-50%, -50%)';
            masteryText.style.fontSize = 'clamp(1.5rem, 6vw, 2.5rem)';
            masteryText.style.fontWeight = 'bold';
            masteryText.style.color = '#00ff00';
            masteryText.style.textShadow = '0 0 20px #00ff00, 0 0 40px #00ff00';
            masteryText.style.textAlign = 'center';
            masteryText.style.fontFamily = 'Courier New, monospace';
            masteryText.style.letterSpacing = '0.2em';
            masteryText.style.opacity = '0';
            masteryText.style.animation = 'masteryText 3s ease-out forwards 0.5s';
            
            // Add final score
            const scoreText = document.createElement('div');
            scoreText.className = 'final-score-text';
            scoreText.textContent = `FINAL SCORE: ${score}`;
            scoreText.style.position = 'absolute';
            scoreText.style.top = '70%';
            scoreText.style.left = '50%';
            scoreText.style.transform = 'translate(-50%, -50%)';
            scoreText.style.fontSize = 'clamp(1rem, 4vw, 1.5rem)';
            scoreText.style.fontWeight = 'bold';
            scoreText.style.color = '#00ffff';
            scoreText.style.textShadow = '0 0 15px #00ffff, 0 0 30px #00ffff';
            scoreText.style.textAlign = 'center';
            scoreText.style.fontFamily = 'Courier New, monospace';
            scoreText.style.letterSpacing = '0.1em';
            scoreText.style.opacity = '0';
            scoreText.style.animation = 'finalScoreText 3s ease-out forwards 1s';
            
            overlay.appendChild(victoryText);
            overlay.appendChild(masteryText);
            overlay.appendChild(scoreText);
            document.body.appendChild(overlay);
            
            // Trigger celebration haptic feedback
            if ('vibrate' in navigator) {
                navigator.vibrate([300, 100, 300, 100, 300, 100, 300]);
            }
            
            // Keep victory screen visible
            console.log(`Victory animation displayed! Final score: ${score}`);
        }
        
        // Enhanced game over
        function gameOver() {
            console.log('üíÄ GAME OVER - No lives remaining üíÄ');
            gameRunning = false;
            gamePaused = false;
            
            // Stop game loops
            if (projectileInterval) clearInterval(projectileInterval);
            if (targetInterval) clearInterval(targetInterval);
            
            // Will implement game over screen later
        }

        function loadNewQuestion() {
            if (flashcards.length === 0) return;
            
            // Progressive Learning: Select cards based on current level and learning state
            const availableCards = getAvailableCards();
            
            if (availableCards.length === 0) {
                console.log('No available cards - checking level completion');
                checkLevelCompletion();
                return;
            }
            
            // Select a random card from available cards
            currentQuestion = availableCards[Math.floor(Math.random() * availableCards.length)];
            document.getElementById('questionText').textContent = currentQuestion.definition;
            
            // Update targets with answers
            updateTargetsWithAnswers();
            
            console.log(`New question: ${currentQuestion.term} (Level ${currentQuestion.progression_level})`);
            
            // Show card state for debugging
            if (cardStates.has(currentQuestion.id)) {
                const state = cardStates.get(currentQuestion.id);
                console.log(`Card state: ${state.state} (${state.consecutiveCorrect} consecutive)`);
            }
        }
        
        // Get available cards based on progression level and learning states
        function getAvailableCards() {
            // Get cards from current progression level
            let availableCards = flashcards.filter(card => 
                card.progression_level === currentProgressionLevel &&
                !learnedCards.has(card.id) // Exclude learned cards
            );
            
            // If no cards available at current level, check if we can advance
            if (availableCards.length === 0) {
                const nextLevel = currentProgressionLevel + 1;
                const nextLevelCards = flashcards.filter(card => 
                    card.progression_level === nextLevel
                );
                
                if (nextLevelCards.length > 0) {
                    // Advance to next level
                    currentProgressionLevel = nextLevel;
                    console.log(`Auto-advancing to Level ${currentProgressionLevel}`);
                    
                    // Initialize new level cards
                    nextLevelCards.forEach(card => {
                        if (!cardStates.has(card.id)) {
                            cardStates.set(card.id, {
                                state: 'new',
                                consecutiveCorrect: 0
                            });
                        }
                    });
                    
                    // Get cards from new level
                    availableCards = nextLevelCards.filter(card => 
                        !learnedCards.has(card.id)
                    );
                }
            }
            
            return availableCards;
        }

        // Target spawning queue and timing
        let targetSpawnQueue = [];
        let targetSpawnDelay = 0;

        function updateTargetsWithAnswers() {
            if (!currentQuestion) return;
            
            // Clear existing targets
            targets.forEach(target => target.element.remove());
            targets = [];
            
            // Clear spawn queue
            targetSpawnQueue = [];
            targetSpawnDelay = 0;
            
            // Queue targets for staggered spawning
            // Now the correct answer is the TERM (since question shows definition)
            const allAnswers = [
                { text: currentQuestion.term, isCorrect: true },
                ...currentQuestion.wrong_answers.map(answer => ({ text: answer, isCorrect: false }))
            ];
            
            // Shuffle answers for random order
            allAnswers.sort(() => Math.random() - 0.5);
            
            // Queue each target with a delay
            allAnswers.forEach((answer, index) => {
                targetSpawnQueue.push({
                    answer: answer.text,
                    isCorrect: answer.isCorrect,
                    delay: index * 800 // 800ms between spawns
                });
            });
            
            // Start spawning targets
            spawnQueuedTargets();
        }

        function spawnQueuedTargets() {
            if (targetSpawnQueue.length === 0) return;
            
            const targetData = targetSpawnQueue.shift();
            createAnswerTarget(targetData.answer, targetData.isCorrect);
            
            // Schedule next target spawn
            if (targetSpawnQueue.length > 0) {
                setTimeout(spawnQueuedTargets, 800);
            }
        }

        function createAnswerTarget(answer, isCorrect) {
            const gameBoard = document.getElementById('gameBoard');
            const boardWidth = gameBoard.offsetWidth;
            const boardHeight = gameBoard.offsetHeight;
            const targetWidth = 80;
            const targetHeight = 60;
            
            // Find a non-overlapping position
            let attempts = 0;
            let left, top;
            let validPosition = false;
            
            while (!validPosition && attempts < 30) {
                // Generate position within horizontal bounds
                left = Math.random() * (boardWidth - targetWidth);
                
                // Start targets at the very top of the game board (inside the cyan box)
                // Position 0 is the top edge of the game board
                top = 0; // Start exactly at the top edge of the game board
                
                // Check for overlaps with existing targets
                validPosition = true;
                for (let existingTarget of targets) {
                    const existingLeft = parseInt(existingTarget.element.style.left);
                    const existingTop = parseInt(existingTarget.element.style.top);
                    
                    // Calculate distance between centers
                    const centerDistance = Math.sqrt(
                        Math.pow(left + targetWidth/2 - (existingLeft + targetWidth/2), 2) +
                        Math.pow(top + targetHeight/2 - (existingTop + targetHeight/2), 2)
                    );
                    
                    // Require minimum 100px separation between centers (reduced from 120px)
                    if (centerDistance < 100) {
                        validPosition = false;
                        break;
                    }
                }
                
                attempts++;
            }
            
            // If no valid position found, use improved fallback grid position
            if (!validPosition) {
                const gridColumns = Math.min(4, Math.floor(boardWidth / (targetWidth + 20))); // Dynamic columns
                const gridX = targets.length % gridColumns;
                const gridY = Math.floor(targets.length / gridColumns);
                
                left = gridX * (boardWidth / gridColumns) + 10;
                // Grid targets start at top of game board, staggered downward
                top = gridY * 70; // Stagger vertically by 70px from top of board
            }
            
            const target = document.createElement('div');
            target.className = 'target';
            target.style.position = 'absolute';
            target.style.width = targetWidth + 'px';
            target.style.height = targetHeight + 'px';
            target.style.borderRadius = '50%';
            target.style.left = left + 'px';
            target.style.top = top + 'px';
            target.style.display = 'flex';
            target.style.alignItems = 'center';
            target.style.justifyContent = 'center';
            target.style.fontFamily = 'Courier New, monospace';
            target.style.fontSize = '10px';
            target.style.fontWeight = 'bold';
            target.style.textAlign = 'center';
            target.style.userSelect = 'none';
            target.style.cursor = 'pointer';
            target.style.zIndex = '10';
            target.textContent = answer;
            
            // Apply correct practice mode styling
            if (isCorrect && highlightCorrectAnswers) {
                // Practice mode ON - highlight correct answers in green
                target.style.border = '2px solid #00ff00';
                target.style.background = 'rgba(0, 255, 0, 0.1)';
                target.style.color = '#00ff00';
                target.style.boxShadow = '0 0 10px #00ff00';
            } else {
                // Practice mode OFF OR wrong answer - use red styling for ALL
                target.style.border = '2px solid #ff0000';
                target.style.background = 'rgba(255, 0, 0, 0.1)';
                target.style.color = '#ff0000';
                target.style.boxShadow = '0 0 10px #ff0000';
            }
            
            gameBoard.appendChild(target);
            
            targets.push({
                element: target,
                y: top,
                isCorrect: isCorrect,
                answer: answer
            });
            
            console.log(`Target created: "${answer.substring(0, 20)}..." at (${left.toFixed(1)}, ${top.toFixed(1)})`);
        }

        // Phase 2: Simple ship movement function
        function moveShip(direction) {
            const ship = document.getElementById('ship');
            const gameBoard = document.getElementById('gameBoard');
            const currentLeft = parseInt(ship.style.left, 10) || 0;
            const newLeft = currentLeft + (direction * 20); // 2x faster: was 10, now 20
            const maxLeft = gameBoard.clientWidth - ship.clientWidth;

            if (newLeft >= 0 && newLeft <= maxLeft) {
                ship.style.left = newLeft + 'px';
                console.log('Ship moved to', newLeft);
            } else {
                console.log('Ship boundary reached at', currentLeft);
            }
        }

        // Phase 3: Projectile system
        let projectiles = [];

        function createProjectile() {
            const ship = document.getElementById('ship');
            const projectile = document.createElement('div');
            projectile.className = 'projectile';
            projectile.style.position = 'absolute';
            projectile.style.width = '5px';
            projectile.style.height = '10px';
            projectile.style.background = '#00ffff';
            projectile.style.left = (parseInt(ship.style.left) + 17) + 'px';
            projectile.style.bottom = '60px';
            document.getElementById('gameBoard').appendChild(projectile);
            
            projectiles.push({
                element: projectile,
                y: 60
            });
            
            console.log('Projectile created at:', projectile.style.left);
        }

        function updateProjectiles() {
            projectiles.forEach((proj, index) => {
                proj.y += 15; // 3x faster: was 5, now 15
                proj.element.style.bottom = proj.y + 'px';
                
                // Check collision with targets
                checkCollisions(proj, index);
                
                if (proj.y > 600) {
                    proj.element.remove();
                    projectiles.splice(index, 1);
                    console.log('Projectile removed');
                }
            });
        }

        // Phase 5: Collision Detection
        function checkCollisions(projectile, projIndex) {
            const projRect = projectile.element.getBoundingClientRect();
            const gameBoard = document.getElementById('gameBoard');
            const gameBoardRect = gameBoard.getBoundingClientRect();
            
            // Use reverse iteration to safely handle target removal
            for (let targetIndex = targets.length - 1; targetIndex >= 0; targetIndex--) {
                const target = targets[targetIndex];
                
                // Skip if target element doesn't exist
                if (!target.element || !target.element.parentNode) {
                    targets.splice(targetIndex, 1);
                    continue;
                }
                
                const targetRect = target.element.getBoundingClientRect();
                
                // Check if projectile overlaps with target
                if (projRect.left < targetRect.right &&
                    projRect.right > targetRect.left &&
                    projRect.top < targetRect.bottom &&
                    projRect.bottom > targetRect.top) {
                    
                    // Collision detected!
                    console.log('Collision detected!');
                    
                    // Remove projectile immediately
                    if (projectile.element && projectile.element.parentNode) {
                        projectile.element.remove();
                    }
                    projectiles.splice(projIndex, 1);
                    
                    // Mark target as hit to prevent further movement
                    target.isHit = true;
                    
                    // Check if answer is correct
                    if (target.isCorrect) {
                        console.log('Correct answer!');
                        updateScore(100); // Award 100 points for correct answer
                        
                        // Progressive Learning: Handle correct answer
                        handleCorrectAnswer(currentQuestion);
                        
                        // Remove target immediately - no freeze
                        if (target.element && target.element.parentNode) {
                            target.element.remove();
                        }
                        // Find and remove target from array
                        const currentIndex = targets.indexOf(target);
                        if (currentIndex > -1) {
                            targets.splice(currentIndex, 1);
                        }
                        loadNewQuestion(); // Load new question on correct answer
                    } else {
                        console.log('Wrong answer!');
                        
                        // Progressive Learning: Handle wrong answer
                        handleWrongAnswer(currentQuestion);
                        
                        // Remove target immediately - no freeze
                        if (target.element && target.element.parentNode) {
                            target.element.remove();
                        }
                        // Find and remove target from array
                        const currentIndex = targets.indexOf(target);
                        if (currentIndex > -1) {
                            targets.splice(currentIndex, 1);
                        }
                    }
                    
                    // Exit after first collision
                    break;
                }
            }
        }

        // Phase 4: Falling Targets system
        let targets = [];

        // createTarget function removed - now using createAnswerTarget from flashcard data

        function updateTargets() {
            // Use reverse iteration to safely remove elements
            for (let index = targets.length - 1; index >= 0; index--) {
                const tgt = targets[index];
                
                // Only update if target still exists in DOM and hasn't been hit
                if (tgt.element && tgt.element.parentNode && !tgt.isHit) {
                    tgt.y += 2;
                    tgt.element.style.top = tgt.y + 'px';
                    
                    // Remove targets that reach the bottom of the game board
                    const gameBoard = document.getElementById('gameBoard');
                    const boardHeight = gameBoard.offsetHeight; // 600px
                    const targetHeight = 60; // Target height from createAnswerTarget
                    
                    // Target should disappear when its BOTTOM reaches the bottom of the game board
                    // tgt.y is the TOP of the target, so bottom = tgt.y + targetHeight
                    if (tgt.y + targetHeight >= boardHeight) { // Remove when target bottom reaches board bottom
                        // Check if this was a correct answer that was missed
                        if (tgt.isCorrect) {
                            console.log('Missed correct answer - losing life');
                            loseLife('missed_correct');
                        }
                        
                        tgt.element.remove();
                        targets.splice(index, 1);
                        console.log('Target removed - bottom reached bottom of game board');
                    }
                } else if (!tgt.element || !tgt.element.parentNode) {
                    // Clean up orphaned target references
                    targets.splice(index, 1);
                    console.log('Orphaned target reference cleaned up');
                }
            }
            
            // Check if all targets have fallen off screen and spawn queue is empty
            if (targets.length === 0 && targetSpawnQueue.length === 0) {
                console.log('All targets cleared - loading new question');
                loadNewQuestion();
            }
        }

        // Phase 1: Tetris-Style Touch Controls Implementation
        function setupTouchControls() {
            const wrapper = document.getElementById('wrapper');
            const gameBoard = document.getElementById('gameBoard');
            
            // Touch state tracking
            let touchStartTime = 0;
            let touchStartPos = { x: 0, y: 0 };
            let longPressTimer = null;
            let isSwipeDown = false;
            let continuousFireTimer = null;
            let isSwipeRight = false;
            let isSwipeLeft = false;
            
            // Get touch zones based on screen layout
            function getTouchZones() {
                const wrapperRect = wrapper.getBoundingClientRect();
                const gameBoardRect = gameBoard.getBoundingClientRect();
                
                // Add 10px gap between zones to prevent overlap
                const zonePadding = 10;
                
                return {
                    // Left zone: left side of screen up to game board (with gap)
                    leftZone: {
                        left: wrapperRect.left,
                        right: gameBoardRect.left - zonePadding,
                        top: gameBoardRect.top,
                        bottom: gameBoardRect.bottom
                    },
                    // Right zone: right side of screen from game board edge (with gap)
                    rightZone: {
                        left: gameBoardRect.right + zonePadding,
                        right: wrapperRect.right,
                        top: gameBoardRect.top,
                        bottom: gameBoardRect.bottom
                    },
                    // Game board zone: the actual game area (no changes)
                    gameBoard: {
                        left: gameBoardRect.left,
                        right: gameBoardRect.right,
                        top: gameBoardRect.top,
                        bottom: gameBoardRect.bottom
                    }
                };
            }
            
            // Determine which zone was touched
            function getTouchZone(x, y) {
                const zones = getTouchZones();
                
                // Check game board first (highest priority) - ONLY fires projectiles
                if (x >= zones.gameBoard.left && x <= zones.gameBoard.right &&
                    y >= zones.gameBoard.top && y <= zones.gameBoard.bottom) {
                    return 'gameBoard';
                }
                
                // Check left zone - ONLY moves ship left
                if (x >= zones.leftZone.left && x <= zones.leftZone.right &&
                    y >= zones.leftZone.top && y <= zones.leftZone.bottom) {
                    return 'left';
                }
                
                // Check right zone - ONLY moves ship right
                if (x >= zones.rightZone.left && x <= zones.rightZone.right &&
                    y >= zones.rightZone.top && y <= zones.rightZone.bottom) {
                    return 'right';
                }
                
                return 'outside';
            }
            
            // Visual feedback for touch zones
            function showTouchFeedback(zone, x, y) {
                const feedback = document.createElement('div');
                feedback.className = `touch-feedback touch-${zone}`;
                feedback.style.position = 'fixed';
                feedback.style.left = (x - 15) + 'px';
                feedback.style.top = (y - 15) + 'px';
                feedback.style.width = '30px';
                feedback.style.height = '30px';
                feedback.style.borderRadius = '50%';
                feedback.style.pointerEvents = 'none';
                feedback.style.zIndex = '1000';
                feedback.style.opacity = '0.8';
                feedback.style.transition = 'all 0.3s ease';
                
                // Zone-specific styling
                if (zone === 'left') {
                    feedback.style.background = 'radial-gradient(circle, rgba(255,0,153,0.8) 0%, rgba(255,0,153,0) 70%)';
                    feedback.innerHTML = '‚Üê';
                    feedback.style.color = '#ff0099';
                    feedback.style.fontSize = '16px';
                    feedback.style.textAlign = 'center';
                    feedback.style.lineHeight = '30px';
                } else if (zone === 'right') {
                    feedback.style.background = 'radial-gradient(circle, rgba(0,255,0,0.8) 0%, rgba(0,255,0,0) 70%)';
                    feedback.innerHTML = '‚Üí';
                    feedback.style.color = '#00ff00';
                    feedback.style.fontSize = '16px';
                    feedback.style.textAlign = 'center';
                    feedback.style.lineHeight = '30px';
                } else if (zone === 'gameBoard') {
                    feedback.style.background = 'radial-gradient(circle, rgba(0,255,255,0.8) 0%, rgba(0,255,255,0) 70%)';
                    feedback.innerHTML = '‚óè';
                    feedback.style.color = '#00ffff';
                    feedback.style.fontSize = '12px';
                    feedback.style.textAlign = 'center';
                    feedback.style.lineHeight = '30px';
                }
                
                document.body.appendChild(feedback);
                
                // Animate and remove
                setTimeout(() => {
                    feedback.style.transform = 'scale(1.5)';
                    feedback.style.opacity = '0';
                }, 50);
                
                setTimeout(() => {
                    if (feedback.parentNode) {
                        feedback.parentNode.removeChild(feedback);
                    }
                }, 350);
            }
            
            // Touch start handler
            wrapper.addEventListener('touchstart', (e) => {
                if (!gameRunning || gamePaused) return;
                
                e.preventDefault();
                touchStartTime = performance.now();
                const touch = e.touches[0];
                touchStartPos = { x: touch.clientX, y: touch.clientY };
                isSwipeDown = false;
                isSwipeRight = false;
                isSwipeLeft = false;
                
                const zone = getTouchZone(touch.clientX, touch.clientY);
                
                // Setup long press for rapid fire (only in game board)
                if (zone === 'gameBoard') {
                    longPressTimer = setTimeout(() => {
                        if (longPressTimer && gameRunning && !gamePaused) {
                            // Start continuous rapid fire
                            continuousFireTimer = setInterval(() => {
                                if (gameRunning && !gamePaused) {
                                    createProjectile();
                                }
                            }, 150); // Fire every 150ms
                            
                            showTouchFeedback('gameBoard', touch.clientX, touch.clientY);
                            console.log('Long press: rapid fire started');
                            
                            // Haptic feedback if supported
                            if ('vibrate' in navigator) {
                                navigator.vibrate(100);
                            }
                        }
                        longPressTimer = null;
                    }, 500); // 500ms for long press
                }
            }, { passive: false });
            
            // Touch move handler
            wrapper.addEventListener('touchmove', (e) => {
                if (!gameRunning || gamePaused) return;
                
                e.preventDefault();
                
                const touch = e.touches[0];
                const currentPos = { x: touch.clientX, y: touch.clientY };
                const deltaY = currentPos.y - touchStartPos.y;
                const deltaX = currentPos.x - touchStartPos.x;
                
                // Check for downward swipe in game board
                const zone = getTouchZone(touch.clientX, touch.clientY);
                if (zone === 'gameBoard' && deltaY > 30 && Math.abs(deltaX) < 50) {
                    if (!isSwipeDown) {
                        isSwipeDown = true;
                        // Start continuous firing on swipe down
                        if (continuousFireTimer) clearInterval(continuousFireTimer);
                        continuousFireTimer = setInterval(() => {
                            if (gameRunning && !gamePaused) {
                                createProjectile();
                            }
                        }, 200); // Fire every 200ms
                        console.log('Swipe down: continuous fire started');
                    }
                }
                
                // NEW: Check for horizontal swipes anywhere on screen
                if (Math.abs(deltaX) > 40 && Math.abs(deltaY) < 30) {
                    if (deltaX > 0 && !isSwipeRight) {
                        // Swipe right - move ship right
                        isSwipeRight = true;
                        moveShip(1);
                        showTouchFeedback('right', touch.clientX, touch.clientY);
                        console.log('Swipe right: move ship right');
                    } else if (deltaX < 0 && !isSwipeLeft) {
                        // Swipe left - move ship left
                        isSwipeLeft = true;
                        moveShip(-1);
                        showTouchFeedback('left', touch.clientX, touch.clientY);
                        console.log('Swipe left: move ship left');
                    }
                }
                
                // Cancel long press if moving significantly
                if (longPressTimer && (Math.abs(deltaX) > 15 || Math.abs(deltaY) > 15)) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            }, { passive: false });
            
            // Touch end handler
            wrapper.addEventListener('touchend', (e) => {
                if (!gameRunning || gamePaused) return;
                
                e.preventDefault();
                
                // Stop continuous firing
                if (continuousFireTimer) {
                    clearInterval(continuousFireTimer);
                    continuousFireTimer = null;
                }
                
                // Cancel long press timer
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                const endTime = performance.now();
                const duration = endTime - touchStartTime;
                const touch = e.changedTouches[0];
                const endPos = { x: touch.clientX, y: touch.clientY };
                
                const deltaX = endPos.x - touchStartPos.x;
                const deltaY = endPos.y - touchStartPos.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // Only process taps (not swipes) and not if it was a swipe down
                if (distance < 25 && duration < 300 && !isSwipeDown && !isSwipeLeft && !isSwipeRight) {
                    const zone = getTouchZone(touch.clientX, touch.clientY);
                    
                    if (zone === 'left') {
                        // Left zone tap - move ship left
                        moveShip(-1);
                        showTouchFeedback('left', touch.clientX, touch.clientY);
                        console.log('Touch: left zone -> move left');
                    } else if (zone === 'right') {
                        // Right zone tap - move ship right
                        moveShip(1);
                        showTouchFeedback('right', touch.clientX, touch.clientY);
                        console.log('Touch: right zone -> move right');
                    } else if (zone === 'gameBoard') {
                        // Game board tap - fire projectile
                        createProjectile();
                        showTouchFeedback('gameBoard', touch.clientX, touch.clientY);
                        console.log('Touch: game board -> fire projectile');
                    }
                }
                
                // Reset swipe states
                isSwipeDown = false;
                isSwipeRight = false;
                isSwipeLeft = false;
            }, { passive: false });
            
            console.log('Touch controls initialized (Tetris-style zones)');
        }

        // Setup deck selection
        function setupDeckSelection() {
            const deckSelect = document.getElementById('deckSelect');
            
            deckSelect.addEventListener('change', async function() {
                const selectedDeckFilename = deckSelect.value;
                console.log(`Deck changed to: ${selectedDeckFilename}`);
                
                // Stop current game if running
                if (gameRunning) {
                    gameRunning = false;
                    gamePaused = false;
                    
                    // Clear intervals
                    if (projectileInterval) clearInterval(projectileInterval);
                    if (targetInterval) clearInterval(targetInterval);
                    
                    // Clear targets and projectiles
                    targets.forEach(target => target.element.remove());
                    targets = [];
                    projectiles.forEach(proj => proj.element.remove());
                    projectiles = [];
                }
                
                // Load the new deck
                try {
                    await discoverAvailableDecks();
                    await loadSelectedDeck(selectedDeckFilename, 1);
                    
                    // Reset game state for new deck
                    score = 0;
                    level = 1;
                    lives = 5;
                    currentProgressionLevel = 1;
                    
                    // Update displays
                    updateScore(0);
                    updateLevel(1);
                    updateLivesDisplay();
                    
                    console.log(`Successfully loaded new deck: ${selectedDeckFilename}`);
                    
                    // Restart game with new deck
                    if (document.getElementById('startOverlay').classList.contains('active')) {
                        // Game hasn't started yet, just load the new deck
                        console.log('Deck ready for when game starts');
                    } else {
                        // Game was running, restart with new deck
                        startGame();
                    }
                    
                } catch (error) {
                    console.error('Failed to load new deck:', error);
                }
            });
        }

        // Initialize game when page loads
        window.addEventListener('load', () => {
            initializeGame();
        });

        // Phase 2 & 3: Keyboard controls (arrow keys + spacebar)
        document.addEventListener('keydown', (e) => {
            if (!gameRunning || gamePaused) return; // Only respond to keys when game is running and not paused
            
            if (e.key === 'ArrowLeft') {
                moveShip(-1);
            } else if (e.key === 'ArrowRight') {
                moveShip(1);
            } else if (e.key === ' ') {
                e.preventDefault(); // Prevent page scroll
                createProjectile();
            }
        });
    </script>
</body>
</html> 