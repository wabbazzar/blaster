<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Card Blaster - Arcade Flashcard Learning Game</title>
    <meta name="description" content="Card Blaster: An arcade-style flashcard learning game with Tron aesthetic. Learn data science concepts while playing!">
    <meta name="keywords" content="flashcards, learning game, data science, arcade game, education">
    <meta name="author" content="Card Blaster Team">
    
    <!-- Open Graph meta tags for social sharing -->
    <meta property="og:title" content="Card Blaster - Arcade Flashcard Learning Game">
    <meta property="og:description" content="Learn data science concepts through an exciting arcade-style game!">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://wabbazzar.github.io/blaster/">
    
    <!-- Twitter Card meta tags -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Card Blaster">
    <meta name="twitter:description" content="Arcade-style flashcard learning game">
    
    <style>
        /* Phase 0 basic reset */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000000; color: #00ffff; font-family: monospace; display: flex; justify-content: center; align-items: center; height: 100vh; }
        h1 { font-size: 2rem; }
    </style>
</head>
<body>
    <div id="wrapper" style="display:flex;flex-direction:column;align-items:center;gap:10px;">
        <h1>Card Blaster</h1>

        <!-- Question Area (static) -->
        <div id="questionArea" style="width:400px;height:100px;border:1px solid #00ffff;display:flex;align-items:center;justify-content:center;">
            <div id="questionText">Question goes here</div>
        </div>

        <!-- Score Display -->
        <div id="scoreArea" style="width:400px;height:30px;border:1px solid #00ffff;display:flex;align-items:center;justify-content:space-between;padding:0 10px;">
            <div>Score: <span id="scoreValue">0</span></div>
            <div>Level: <span id="levelValue">1</span></div>
        </div>

        <!-- Game Board (static) -->
        <div id="gameBoard" style="position:relative;width:400px;height:600px;border:1px solid #00ffff;">
            <!-- Ship (static) -->
            <div id="ship" style="position:absolute;bottom:20px;left:180px;width:40px;height:40px;background:#00ffff;"></div>
        </div>
    </div>

    <script>
        // Phase 6: Data Integration
        let flashcards = [];
        let currentQuestion = null;

        // Phase 7: Scoring System
        let score = 0;
        let level = 1;

        function updateScore(points) {
            score += points;
            document.getElementById('scoreValue').textContent = score;
            console.log('Score updated:', score);
        }

        function updateLevel(newLevel) {
            level = newLevel;
            document.getElementById('levelValue').textContent = level;
            console.log('Level updated:', level);
        }

        async function loadFlashcards() {
            try {
                const response = await fetch('assets/data_science_cards.json');
                flashcards = await response.json();
                console.log('Loaded flashcards:', flashcards.length);
                loadNewQuestion();
            } catch (error) {
                console.error('Error loading flashcards:', error);
                // Fallback data
                flashcards = [
                    {
                        "id": 1,
                        "term": "Machine Learning",
                        "definition": "A type of artificial intelligence where computers learn patterns from data",
                        "wrong_answers": ["Data Mining", "Statistical Analysis", "Computer Vision"],
                        "progression_level": 1
                    }
                ];
                loadNewQuestion();
            }
        }

        function loadNewQuestion() {
            if (flashcards.length === 0) return;
            
            // For now, just pick a random card from progression level 1
            const level1Cards = flashcards.filter(card => card.progression_level === 1);
            if (level1Cards.length === 0) return;
            
            currentQuestion = level1Cards[Math.floor(Math.random() * level1Cards.length)];
            document.getElementById('questionText').textContent = currentQuestion.definition;
            
            // Update targets with answers
            updateTargetsWithAnswers();
            
            console.log('New question:', currentQuestion.term);
        }

        // Target spawning queue and timing
        let targetSpawnQueue = [];
        let targetSpawnDelay = 0;

        function updateTargetsWithAnswers() {
            if (!currentQuestion) return;
            
            // Clear existing targets
            targets.forEach(target => target.element.remove());
            targets = [];
            
            // Clear spawn queue
            targetSpawnQueue = [];
            targetSpawnDelay = 0;
            
            // Queue targets for staggered spawning
            // Now the correct answer is the TERM (since question shows definition)
            const allAnswers = [
                { text: currentQuestion.term, isCorrect: true },
                ...currentQuestion.wrong_answers.map(answer => ({ text: answer, isCorrect: false }))
            ];
            
            // Shuffle answers for random order
            allAnswers.sort(() => Math.random() - 0.5);
            
            // Queue each target with a delay
            allAnswers.forEach((answer, index) => {
                targetSpawnQueue.push({
                    answer: answer.text,
                    isCorrect: answer.isCorrect,
                    delay: index * 800 // 800ms between spawns
                });
            });
            
            // Start spawning targets
            spawnQueuedTargets();
        }

        function spawnQueuedTargets() {
            if (targetSpawnQueue.length === 0) return;
            
            const targetData = targetSpawnQueue.shift();
            createAnswerTarget(targetData.answer, targetData.isCorrect);
            
            // Schedule next target spawn
            if (targetSpawnQueue.length > 0) {
                setTimeout(spawnQueuedTargets, 800);
            }
        }

        function createAnswerTarget(answer, isCorrect) {
            const gameBoard = document.getElementById('gameBoard');
            const boardWidth = gameBoard.offsetWidth;
            const boardHeight = gameBoard.offsetHeight;
            const targetWidth = 80;
            const targetHeight = 60;
            
            // Find a non-overlapping position
            let attempts = 0;
            let left, top;
            let validPosition = false;
            
            while (!validPosition && attempts < 30) {
                // Generate position within horizontal bounds
                left = Math.random() * (boardWidth - targetWidth);
                
                // Start targets at the very top of the game board (inside the cyan box)
                // Position 0 is the top edge of the game board
                top = 0; // Start exactly at the top edge of the game board
                
                // Check for overlaps with existing targets
                validPosition = true;
                for (let existingTarget of targets) {
                    const existingLeft = parseInt(existingTarget.element.style.left);
                    const existingTop = parseInt(existingTarget.element.style.top);
                    
                    // Calculate distance between centers
                    const centerDistance = Math.sqrt(
                        Math.pow(left + targetWidth/2 - (existingLeft + targetWidth/2), 2) +
                        Math.pow(top + targetHeight/2 - (existingTop + targetHeight/2), 2)
                    );
                    
                    // Require minimum 100px separation between centers (reduced from 120px)
                    if (centerDistance < 100) {
                        validPosition = false;
                        break;
                    }
                }
                
                attempts++;
            }
            
            // If no valid position found, use improved fallback grid position
            if (!validPosition) {
                const gridColumns = Math.min(4, Math.floor(boardWidth / (targetWidth + 20))); // Dynamic columns
                const gridX = targets.length % gridColumns;
                const gridY = Math.floor(targets.length / gridColumns);
                
                left = gridX * (boardWidth / gridColumns) + 10;
                // Grid targets start at top of game board, staggered downward
                top = gridY * 70; // Stagger vertically by 70px from top of board
            }
            
            const target = document.createElement('div');
            target.className = 'target';
            target.style.position = 'absolute';
            target.style.width = targetWidth + 'px';
            target.style.height = targetHeight + 'px';
            target.style.background = isCorrect ? '#00ff00' : '#ff6600';
            target.style.border = '2px solid #00ffff';
            target.style.borderRadius = '10px';
            target.style.left = left + 'px';
            target.style.top = top + 'px';
            target.style.display = 'flex';
            target.style.alignItems = 'center';
            target.style.justifyContent = 'center';
            target.style.color = '#ffffff';
            target.style.fontSize = '10px';
            target.style.textAlign = 'center';
            target.style.padding = '2px';
            target.style.overflow = 'hidden';
            target.textContent = answer.substring(0, 30) + (answer.length > 30 ? '...' : '');
            target.dataset.isCorrect = isCorrect;
            target.dataset.fullAnswer = answer;
            gameBoard.appendChild(target);
            
            targets.push({
                element: target,
                y: top,
                isCorrect: isCorrect,
                answer: answer
            });
            
            console.log(`Target created: "${answer.substring(0, 20)}..." at (${left.toFixed(1)}, ${top.toFixed(1)})`);
        }

        // Phase 2: Simple ship movement function
        function moveShip(direction) {
            const ship = document.getElementById('ship');
            const gameBoard = document.getElementById('gameBoard');
            const currentLeft = parseInt(ship.style.left, 10) || 0;
            const newLeft = currentLeft + (direction * 20); // 2x faster: was 10, now 20
            const maxLeft = gameBoard.clientWidth - ship.clientWidth;

            if (newLeft >= 0 && newLeft <= maxLeft) {
                ship.style.left = newLeft + 'px';
                console.log('Ship moved to', newLeft);
            } else {
                console.log('Ship boundary reached at', currentLeft);
            }
        }

        // Phase 3: Projectile system
        let projectiles = [];

        function createProjectile() {
            const ship = document.getElementById('ship');
            const projectile = document.createElement('div');
            projectile.className = 'projectile';
            projectile.style.position = 'absolute';
            projectile.style.width = '5px';
            projectile.style.height = '10px';
            projectile.style.background = '#00ffff';
            projectile.style.left = (parseInt(ship.style.left) + 17) + 'px';
            projectile.style.bottom = '60px';
            document.getElementById('gameBoard').appendChild(projectile);
            
            projectiles.push({
                element: projectile,
                y: 60
            });
            
            console.log('Projectile created at:', projectile.style.left);
        }

        function updateProjectiles() {
            projectiles.forEach((proj, index) => {
                proj.y += 15; // 3x faster: was 5, now 15
                proj.element.style.bottom = proj.y + 'px';
                
                // Check collision with targets
                checkCollisions(proj, index);
                
                if (proj.y > 600) {
                    proj.element.remove();
                    projectiles.splice(index, 1);
                    console.log('Projectile removed');
                }
            });
        }

        // Phase 5: Collision Detection
        function checkCollisions(projectile, projIndex) {
            const projRect = projectile.element.getBoundingClientRect();
            const gameBoard = document.getElementById('gameBoard');
            const gameBoardRect = gameBoard.getBoundingClientRect();
            
            // Use reverse iteration to safely handle target removal
            for (let targetIndex = targets.length - 1; targetIndex >= 0; targetIndex--) {
                const target = targets[targetIndex];
                
                // Skip if target element doesn't exist
                if (!target.element || !target.element.parentNode) {
                    targets.splice(targetIndex, 1);
                    continue;
                }
                
                const targetRect = target.element.getBoundingClientRect();
                
                // Check if projectile overlaps with target
                if (projRect.left < targetRect.right &&
                    projRect.right > targetRect.left &&
                    projRect.top < targetRect.bottom &&
                    projRect.bottom > targetRect.top) {
                    
                    // Collision detected!
                    console.log('Collision detected!');
                    
                    // Remove projectile immediately
                    if (projectile.element && projectile.element.parentNode) {
                        projectile.element.remove();
                    }
                    projectiles.splice(projIndex, 1);
                    
                    // Mark target as hit to prevent further movement
                    target.isHit = true;
                    
                    // Check if answer is correct
                    if (target.isCorrect) {
                        console.log('Correct answer!');
                        updateScore(100); // Award 100 points for correct answer
                        
                        // Remove target immediately - no freeze
                        if (target.element && target.element.parentNode) {
                            target.element.remove();
                        }
                        // Find and remove target from array
                        const currentIndex = targets.indexOf(target);
                        if (currentIndex > -1) {
                            targets.splice(currentIndex, 1);
                        }
                        loadNewQuestion(); // Load new question on correct answer
                    } else {
                        console.log('Wrong answer!');
                        
                        // Remove target immediately - no freeze
                        if (target.element && target.element.parentNode) {
                            target.element.remove();
                        }
                        // Find and remove target from array
                        const currentIndex = targets.indexOf(target);
                        if (currentIndex > -1) {
                            targets.splice(currentIndex, 1);
                        }
                    }
                    
                    // Exit after first collision
                    break;
                }
            }
        }

        // Phase 4: Falling Targets system
        let targets = [];

        // createTarget function removed - now using createAnswerTarget from flashcard data

        function updateTargets() {
            // Use reverse iteration to safely remove elements
            for (let index = targets.length - 1; index >= 0; index--) {
                const tgt = targets[index];
                
                // Only update if target still exists in DOM and hasn't been hit
                if (tgt.element && tgt.element.parentNode && !tgt.isHit) {
                    tgt.y += 2;
                    tgt.element.style.top = tgt.y + 'px';
                    
                    // Remove targets that reach the bottom of the game board
                    const gameBoard = document.getElementById('gameBoard');
                    const boardHeight = gameBoard.offsetHeight; // 600px
                    const targetHeight = 60; // Target height from createAnswerTarget
                    
                    // Target should disappear when its BOTTOM reaches the bottom of the game board
                    // tgt.y is the TOP of the target, so bottom = tgt.y + targetHeight
                    if (tgt.y + targetHeight >= boardHeight) { // Remove when target bottom reaches board bottom
                        tgt.element.remove();
                        targets.splice(index, 1);
                        console.log('Target removed - bottom reached bottom of game board');
                    }
                } else if (!tgt.element || !tgt.element.parentNode) {
                    // Clean up orphaned target references
                    targets.splice(index, 1);
                    console.log('Orphaned target reference cleaned up');
                }
            }
            
            // Check if all targets have fallen off screen and spawn queue is empty
            if (targets.length === 0 && targetSpawnQueue.length === 0) {
                console.log('All targets cleared - loading new question');
                loadNewQuestion();
            }
        }

        // Start update loops
        setInterval(updateProjectiles, 50);
        setInterval(updateTargets, 50);

        // Initialize game
        window.addEventListener('load', () => {
            loadFlashcards();
        });

        // Phase 2 & 3: Keyboard controls (arrow keys + spacebar)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                moveShip(-1);
            } else if (e.key === 'ArrowRight') {
                moveShip(1);
            } else if (e.key === ' ') {
                e.preventDefault(); // Prevent page scroll
                createProjectile();
            }
        });
    </script>
</body>
</html> 